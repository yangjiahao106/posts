---
title: mysql 锁的分类
date: 2020-05-25 20:22:49
tags:
---

# 加锁机制分类：
![image](736A25C1A8C64EB7BDBC2D4D1577E1CE)

## 1、乐观锁：先修改，保存时判断是够被更新过，应用级别

乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。
### 1.1通过 version 实现：

```mysql
-- 使用version 实现乐观锁

--1.查询出商品信息

select (status,status,version) from t_goods where id=#{id}

--2.根据商品信息生成订单

--3.修改商品status为2

update t_goods 

set status=2,version=version+1

where id=#{id} and version=#{version};

```
### 1.2. 通过 CAS算法 实现
即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数

需要读写的内存值 V
进行比较的值 A
拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

乐观锁的缺点 **todo** 

作者：Guide哥
链接：https://juejin.im/post/5b4977ae5188251b146b2fc8
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 2、悲观锁：先获取锁，再操作修改，数据库级别， 比如**行锁，表锁等，读锁，写锁**等，都是在做操作之前先上锁

### 2.1. 共享锁 
又称之为读锁，简称S锁，当事务对数据加上读锁后，其他事务只能对该数据加读锁，不能做任何修改操作，也就是不能添加写锁。只有当数据上的读锁被释放后，其他事务才能对其添加写锁。共享锁主要是为了支持并发的读取数据而出现的，读取数据时，不允许其他事务对当前数据进行修改操作，从而避免”不可重读”的问题的出现。

``` sql
SELECT * from city where id = "1"  lock in share mode; 
```

### 2.2 排它锁
又称之为写锁，简称X锁，当事务对数据加上写锁后，其他事务既不能对该数据添加读写，也不能对该数据添加写锁，写锁与其他锁都是互斥的。只有当前数据写锁被释放后，其他事务才能对其添加写锁或者是读锁。写锁主要是为了解决在修改数据时，不允许其他事务对当前数据进行修改和读取操作，从而可以有效避免”脏读”问题的产生。

当我们使用sql语句做查询操作，**<u>命中索引则添加行锁**</u>，此时，共享指定行；**<u>没有命中索引则添加表锁</u>**，则共享整张表。通过上图我们知道，共享锁只能兼容共享锁，不兼容排它锁，并且，排它锁互斥共享锁和其它排它锁。我们在数据库操作一遍试试看：
update,insert,delete语句会自动加排它锁的原因， select for update 也会加排它锁

### MVCC

